<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gioco del Cavallo - Tour del Cavallo</title>
<style>
  body {
    font-family: sans-serif;
    text-align: center;
    margin-top: 20px;
    user-select: none;
  }
  canvas {
    border: 2px solid black;
    margin-top: 10px;
    width: 360px;
    height: 360px;
    cursor: pointer;
  }
  .controls {
    margin-top: 20px;
    display: flex;
    justify-content: center;
    gap: 20px;
  }
  button.circle-button {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    font-size: 28px;
    border: none;
    background-color: #007AFF;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }
  #resetBtn {
    background: linear-gradient(145deg, #a3f7cf, #79d2b8);
    padding: 0;
  }
</style>
</head>
<body>
<h2>♞ Gioco del Cavallo ♞</h2>
<canvas id="board" width="360" height="360"></canvas>
<div class="controls">
  <button id="startBtn" class="circle-button">▶</button>
  <button id="resetBtn" class="circle-button">↻</button>
</div>

<script>
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const size = 8;
const cell = canvas.width / size;

const lightCell = "#f0d9b5";
const darkCell = "#b58863";
const visitedManualColor = "rgba(255, 255, 100, 0.7)"; 
const visitedAutoColor = "rgba(0, 255, 170, 0.5)";
const highlightColor = "#00cfff";

let mode = 'auto'; // 'auto' or 'manual'
let tour = [];
let step = 0;
let currentPos = null;
let manualPath = [];
let failShown = false;
let completedShown = false;

function valid(x, y) {
  return x >= 0 && x < size && y >= 0 && y < size;
}

function knightMoves(x, y) {
  const moves = [
    [x+2,y+1],[x+2,y-1],[x-2,y+1],[x-2,y-1],
    [x+1,y+2],[x+1,y-2],[x-1,y+2],[x-1,y-2]
  ];
  return moves.filter(([mx,my]) => valid(mx,my));
}

function warnsdorffTour(sx, sy, blocked=[]) {
  const board = Array(size).fill(null).map(() => Array(size).fill(-1));
  for(const [bx,by] of blocked) {
    board[by][bx] = -2;
  }
  board[sy][sx] = 0;
  const path = [[sx, sy]];

  for(let step = 1; step < size*size - blocked.length; step++) {
    const [x,y] = path[path.length-1];
    let candidates = knightMoves(x,y)
      .filter(([cx,cy]) => board[cy][cx] === -1)
      .map(([cx,cy]) => {
        const onwardMoves = knightMoves(cx,cy).filter(([nx,ny]) => board[ny][nx] === -1);
        return {pos:[cx,cy], count:onwardMoves.length};
      })
      .sort((a,b) => a.count - b.count);

    if(candidates.length === 0) return null;

    const next = candidates[0].pos;
    board[next[1]][next[0]] = step;
    path.push(next);
  }
  return path;
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for(let y=0; y<size; y++) {
    for(let x=0; x<size; x++) {
      const isLight = (x+y) % 2 === 0;
      ctx.fillStyle = isLight ? lightCell : darkCell;
      ctx.fillRect(x*cell, y*cell, cell, cell);
    }
  }

  if(mode === 'auto') {
    for(let i = 0; i < step; i++) {
      const [x,y] = tour[i];
      ctx.fillStyle = visitedAutoColor;
      ctx.fillRect(x*cell, y*cell, cell, cell);
    }
  } else if(mode === 'manual') {
    for(let i = 0; i < manualPath.length; i++) {
      const [x,y] = manualPath[i];
      ctx.fillStyle = visitedManualColor;
      ctx.fillRect(x*cell, y*cell, cell, cell);
    }
  }

  ctx.fillStyle = "#000";
  ctx.textBaseline = "top";
  ctx.textAlign = "left";
  ctx.font = "bold 14px sans-serif";
  if(mode === 'auto') {
    for(let i = 0; i < step; i++) {
      const [x,y] = tour[i];
      ctx.fillText(i+1, x*cell + 4, y*cell + 2);
    }
  } else if(mode === 'manual') {
    for(let i = 0; i < manualPath.length; i++) {
      const [x,y] = manualPath[i];
      ctx.fillText(i+1, x*cell + 4, y*cell + 2);
    }
  }

  if(mode === 'manual' && currentPos) {
    const validMoves = getValidNextMoves();
    if(validMoves.length > 0) {
      const alpha = 0.5 + 0.5 * Math.sin(Date.now()/300);
      ctx.fillStyle = highlightColor;
      ctx.globalAlpha = alpha;
      for(const [mx,my] of validMoves) {
        ctx.fillRect(mx*cell, my*cell, cell, cell);
      }
      ctx.globalAlpha = 1;
    }
  }

  if(currentPos) {
    drawKnight(currentPos[0], currentPos[1]);
  }
}

function drawKnight(x,y) {
  ctx.fillStyle = "blue";
  ctx.beginPath();
  ctx.arc(x*cell + cell/2, y*cell + cell/2, cell/3, 0, 2*Math.PI);
  ctx.fill();
}

function getValidNextMoves() {
  if(!currentPos) return [];

  const allMoves = knightMoves(currentPos[0], currentPos[1]);

  if(mode === 'manual') {
    return allMoves.filter(([mx,my]) => !manualPath.some(([px,py]) => px === mx && py === my));
  } else {
    return allMoves.filter(([mx,my]) => {
      const idx = tour.findIndex(([tx,ty]) => tx === mx && ty === my);
      return idx === -1 || idx >= step;
    });
  }
}

function resetBoard() {
  mode = 'auto';
  tour = [];
  step = 0;
  currentPos = null;
  manualPath = [];
  failShown = false;
  completedShown = false;
  drawBoard();
}

function advanceAuto() {
  if(tour.length === 0) {
    const startX = 0;
    const startY = 0;
    const newTour = warnsdorffTour(startX, startY);
    if(!newTour) {
      alert("Impossibile completare il tour da (0,0).");
      resetBoard();
      return;
    }
    tour = newTour;
    step = 0;
  }

  if(step < tour.length) {
    currentPos = tour[step];
    step++;
    drawBoard();
    if(step === tour.length && !completedShown) {
      alert("Tour completato!");
      completedShown = true;
    }
  }
}

function advanceManualAlgo() {
  if(!currentPos) {
    alert("Posiziona il cavallo cliccando su una cella per giocare manualmente.");
    return;
  }

  const blocked = manualPath.slice(0, -1);
  const newTour = warnsdorffTour(currentPos[0], currentPos[1], blocked);

  if(!newTour) {
    if(!failShown) {
      alert("Non è possibile completare il gioco, riprovare!");
      failShown = true;
    }
    return;
  }

  const nextStep = manualPath.length;
  if(nextStep >= newTour.length) {
    if(!completedShown) {
      alert("Tour completato!");
      completedShown = true;
    }
    return;
  }

  const nextPos = newTour[nextStep];
  if(manualPath.some(([px,py]) => px === nextPos[0] && py === nextPos[1])) {
    if(!failShown) {
      alert("Non è possibile completare il gioco, riprovare!");
      failShown = true;
    }
    return;
  }

  currentPos = nextPos;
  manualPath.push(currentPos);
  drawBoard();

  if(manualPath.length === size*size && !completedShown) {
    alert("Tour completato!");
    completedShown = true;
  }
}

function onBoardClick(evt) {
  if(mode === 'auto') return;

  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((evt.clientX - rect.left) / cell);
  const y = Math.floor((evt.clientY - rect.top) / cell);
  if(!valid(x,y)) return;

  if(manualPath.length === 0) {
    currentPos = [x,y];
    manualPath.push(currentPos);
    failShown = false;
    completedShown = false;
    drawBoard();
    return;
  }

  const validMoves = getValidNextMoves();
  if(validMoves.some(([mx,my]) => mx === x && my === y)) {
    currentPos = [x,y];
    manualPath.push(currentPos);
    drawBoard();

    if(manualPath.length === size*size && !completedShown) {
      alert("Tour completato!");
      completedShown = true;
    }
  }
}

document.getElementById('startBtn').onclick = () => {
  if(mode === 'auto') {
    advanceAuto();
  } else {
    advanceManualAlgo();
  }
};

document.getElementById('resetBtn').onclick = () => {
  resetBoard();
};

canvas.onclick = (evt) => {
  if(mode === 'auto') {
    mode = 'manual';
    resetBoard();
    onBoardClick(evt);
  } else {
    onBoardClick(evt);
  }
};

resetBoard();

function animate() {
  drawBoard();
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
